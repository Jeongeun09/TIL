# DI란?
DI란 Dependency Injetion의 약자이다. DI는 의존성 주입이라는 의미를 가지는데 객체 간의 관계를 나타내고 형성하는 역할을 한다. DI는 다른 클래스에 있는 외부의 객체를 주입하는 것과 같은데 코드 설계 패턴 중 하나에 속합니다.

 ---- 

## DI의 종류

### 1.  생성자 주입

객체를 생성할 때 필요한 의존성을 생성자를 통해 주입시켜주는 방식이다.



#### 특징

- final을 통해 주입 가능하다.
- 불변성을 보장할 수 있다.
- Spring에서 가장 많이 권장되는 방식


장점 : 테스트 용이, 쉽게 주입 가능

단점 : 의존성을 너무 많이 주입하게 되면 생성자가 많아질 가능성이 높아진다.

 

### 2.  세터(Setter) 주입

객체 생성 후에 Spring에서 사용되는 Setter라는 어노테이션을 사용하여 주입하는 방식이다.


특징

- 객체 생성 후에도 의존성을 변경할 수 있다.

장점 : 코드가 상대적으로 다른 방법보다 단순하다.

단점 : 객체 불변성 보장이 되지 않는다.


## 3.  필드 주입(Autowired)

객체를 만들 때 필드에 Autowired라는 어노테이션을 사용하여 주입하는 방식이다.



특징

- 코드가 간결
- Spring 프레임워크에 지나치게 의존

장점 : 코드가 가장 짧고 간단

단점 : 객체 불변성 보장 불가, 코드로만 보면 의존성 확인 불가, 테스트 어려움

 ----- 

## DI를 사용하는 이유

1. 결합도 낮추기
DI는 단순 new 객체를 만들지 않고 외부에서 주입 받는 것이 아니다. 예를 들어 Service에서 Repository를 만들게 되면 결합도가 높아지고 유연성이 떨어지게 된다.
그렇게 되면 유지보수하기도 힘들어지고 다른 객체를 주입받아야 할 때 오류가 생길 수 있다.

2. 책임 분리하기
SOLID 원칙에 나왔듯이 단일 책임 원칙이라는 것을 실천했을 때 좋다. 왜냐하면 객체는 자신이 속한 클래스가 처리하는 로직에 집중하고
의존성 주입 같은 동작들은 DI와 같은 컴포넌트에 넘기면서 책임이 서로에게 분리가 되기 때문이다.

3. 유지보수, 유연성
클래스 자체를 외부에서 주입받게 되면 유지보수가 힘들어지고 유연성이 떨어진다. 하지만 객체를 외부에서 주입받게 되면 로직을 짤 때 구현하기 위해서 사용되는 코드 양이 줄어들어 가독성이 좋아진다.

4. 테스트 용이
DI를 사용하게 되면 내가 직접 다 만든 객체가 아닌 가상의 객체인 Mock, Stubs 같은 것들을 사용하여 테스트를 쉽게 할 수 있다. 
또한 간단한 테스트를 거칠 때에는 DB 연결 없이 테스트가 가능하다.

5. 객체의 생명주기
Spring은 DI 컨포넌트이다. 그렇기 때문에 Spring이 객체를 관리해주기 때문에 개발자가 일정 기간마다 객체를 확인하고 수정하는 일이 없기 때문에 생산성이 좋아진다.

---- 
## DI 사용 장단점

#### 장점
- 코드 재사용성 증가
- 유지보수 수월
- 객체 생성과 관심사 분리
 
#### 단점 

- 초기 학습 난이도
- 지나친 DI 사용은 코드의 가독성을 떨어트린다.

  ----
  ## DI 사용할 때 주의할 점

  
#### 의존성 과다
한 클래스에서 많은 객체를 주입 받게 되면 SOLID 원칙에 속한 SRP라는 단일 책임 원칙에 따르지 않는 거라고 할 수 있다. 
DI는 SOLID 원칙을 실천하여 프로그래밍을 좋게 하려는 의도로 사용하는 것이기 때문에 한 클래스에서 많은 객체를 주입 받지 않도록 주의해야 한다.

#### 순환 참조
만약 A와 B가 있다면 A가 B를 주입받았지만 B가 다시 A를 주입받게 되었을 때에는 Spring이 자동으로 Bean으로 등록해주지 않게 된다. 
Bean으로 등록해주지 않는다면 Spring에선 Bean을 찾을 수 없다는 오류가 발생할 수 있기 때문에 주의해야 한다.

#### 필드 주입
Spring에선 필드를 주입할 때 @Autowired 라는 어노테이션을 사용한다. 하지만 이 어노테이션을 사용하게 되면 테스트, 프레임워크 의존성과 같은 부분에서 문제를 일으킬 수 있다.

#### Autowired를 사용했을 때
→ 실행할 때 객체가 변경될 수 있고 한 번 주입됐을 때 변경되지 않는다는 보장을 할 수 없다. 또한 이 어노테이션은 Spring이 컴파일 할 때 주입이 되기 때문에 
해당 Bean이 만들어지지 않았을 때에는 오류가 발생한다.


#### final을 사용할 때
→ 실행할 때 객체가 변경되지 않는다는 보장이 되기 때문에 안전하다. 또한 Spring을 컴파일 할 때 오류가 발생하여 문제점을 찾지 않고 개발 단계에서 오류가 발생하여 고칠 수 있다.

----- 

### DI 코드
 

@Service
public class PasswordResetService {


    private final PasswordEncoder passwordEncoder;

    private final UserRepository userRepository;

    public PasswordResetService(PasswordEncoder passwordEncoder, UserRepository userRepository) {
        this.passwordEncoder = passwordEncoder;
        this.userRepository = userRepository;
    }
 

원래는 Autowired를 사용하여 DI를 했지만 DI를 공부하면서 생성자인 final을 이용하는 것이 좋다고 판단하여 수정하게 됐다.
